trigger:
  branches:
    include:
      - main
  paths:
    include:
      - backend-a/**
      - backend-b/**
      - k8s/**
      - pipelines/api.yml

pool:
  vmImage: ubuntu-latest

variables:
- group: db-secrets

- name: AZURE_SERVICE_CONNECTION
  value: "moath-sp-new"

- name: ACR_NAME
  value: "acrmoath"

- name: ACR_LOGIN_SERVER
  value: "acrmoath.azurecr.io"

# ---------- SONARQUBE ----------
- name: SONARQUBE_URL
  value: "http://20.64.246.3:9000"

- name: SONARQUBE_PROJECT_KEY
  value: "moath-api"

- name: SONARQUBE_PROJECT_NAME
  value: "moath-api"

stages:

# =========================================================
# BUILD + SAST + IMAGE SCAN
# =========================================================
- stage: Build
  displayName: "SAST + Build + Container Scan + Push"
  jobs:
  - job: BuildPush
    steps:
    - checkout: self

    # ---------- RUN SONARQUBE SCAN ----------
    - script: |
        docker run --rm \
          -e SONAR_HOST_URL=$(SONARQUBE_URL) \
          -e SONAR_TOKEN=$(SONARQUBE_TOKEN) \
          -v $(System.DefaultWorkingDirectory):/usr/src \
          sonarsource/sonar-scanner-cli:latest \
          -Dsonar.projectKey=$(SONARQUBE_PROJECT_KEY) \
          -Dsonar.projectName="$(SONARQUBE_PROJECT_NAME)" \
          -Dsonar.sources=backend-a,backend-b \
          -Dsonar.java.binaries=. \
          -Dsonar.qualitygate.wait=true
      displayName: "Run SonarQube Analysis (Docker Scanner)"
      env:
        SONARQUBE_TOKEN: $(SONARQUBE_TOKEN)

    # ---------- LOGIN TO ACR ----------
    - task: AzureCLI@2
      displayName: "Azure Login ACR"
      inputs:
        azureSubscription: $(AZURE_SERVICE_CONNECTION)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          az acr login --name $(ACR_NAME)

    # ---------- BUILD DOCKER ----------
    - script: |
        docker build -t backend-a-local ./backend-a
        docker build -t backend-b-local ./backend-b
      displayName: "Build Docker Images"

    # ---------- INSTALL TRIVY ----------
    - script: |
        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
          | sh -s -- -b /usr/local/bin
      displayName: "Install Trivy"

    # ---------- REPORTS ----------
    - script: |
        curl -sSL -o html.tpl https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl
      displayName: "Download Trivy HTML template"

    - script: |
        trivy image --format template --template "@html.tpl" --output trivy-backend-a.html backend-a-local
        trivy image --format template --template "@html.tpl" --output trivy-backend-b.html backend-b-local
      displayName: "Generate Trivy HTML Reports"

    - script: |
        trivy image --severity CRITICAL --exit-code 1 backend-a-local
        trivy image --severity CRITICAL --exit-code 1 backend-b-local
      displayName: "Fail Build if Critical CVEs Found"

    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: "$(System.DefaultWorkingDirectory)"
        ArtifactName: "trivy-reports"
        publishLocation: "Container"
      displayName: "Publish Trivy HTML Reports"

    # ---------- PUSH IMAGES ----------
    - script: |
        docker tag backend-a-local $(ACR_LOGIN_SERVER)/backend-a-moath:latest
        docker tag backend-b-local $(ACR_LOGIN_SERVER)/backend-b-moath:latest
        docker push $(ACR_LOGIN_SERVER)/backend-a-moath:latest
        docker push $(ACR_LOGIN_SERVER)/backend-b-moath:latest
      displayName: "Push Images to ACR"

# =========================================================
# DEV DEPLOY
# =========================================================
- stage: Dev
  dependsOn: Build
  jobs:
  - deployment: DeployDev
    environment: dev
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g rg-moath-dev -n aks-moath-dev --overwrite-existing

                # ----- NAMESPACE -----
                kubectl apply -f k8s/namespaces/dev.yaml

                # ----- SECRET FROM PIPELINE VARIABLE -----
                kubectl create secret generic postgres-secret-moath \
                  --from-literal=POSTGRES_PASSWORD=$(DB_PASSWORD_DEV) \
                  -n moath-webapp-dev --dry-run=client -o yaml | kubectl apply -f -

                # ----- DEPLOY -----
                kubectl apply -k k8s/overlays/dev

# =========================================================
# QA DEPLOY
# =========================================================
- stage: QA
  dependsOn: Dev
  jobs:
  - deployment: DeployQA
    environment: qa
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g rg-moath-qa -n aks-moath-qa --overwrite-existing

                kubectl apply -f k8s/namespaces/qa.yaml

                kubectl create secret generic postgres-secret-moath \
                  --from-literal=POSTGRES_PASSWORD=$(DB_PASSWORD_QA) \
                  -n moath-webapp-qa --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -k k8s/overlays/qa

# =========================================================
# PROD DEPLOY
# =========================================================
- stage: Prod
  dependsOn: QA
  jobs:
  - deployment: DeployProd
    environment: prod
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials -g rg-moath-prod -n aks-moath-prod --overwrite-existing

                kubectl apply -f k8s/namespaces/prod.yaml

                kubectl create secret generic postgres-secret-moath \
                  --from-literal=POSTGRES_PASSWORD=$(DB_PASSWORD_PROD) \
                  -n moath-webapp-prod --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -k k8s/overlays/prod

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - backend-a/**
      - backend-b/**
      - k8s/**
      - pipelines/api.yml

pool:
  vmImage: ubuntu-latest

variables:
- group: db-secrets

- name: AZURE_SERVICE_CONNECTION
  value: "moath-sp-new"

- name: ACR_NAME
  value: "acrmoath"

- name: ACR_LOGIN_SERVER
  value: "acrmoath.azurecr.io"

# ---------- SONARQUBE ----------
- name: SONARQUBE_URL
  value: "http://20.64.246.3:9000"

- name: SONARQUBE_PROJECT_KEY
  value: "moath-api"

- name: SONARQUBE_PROJECT_NAME
  value: "moath-api"

stages:

# =========================================================
# BUILD + SAST + IMAGE SCAN
# =========================================================
- stage: Build
  displayName: "SAST + Build + Container Scan + Push"
  jobs:
  - job: BuildPush
    steps:
    - checkout: self

    - script: |
        docker run --rm \
          -e SONAR_HOST_URL=$(SONARQUBE_URL) \
          -e SONAR_TOKEN=$(SONARQUBE_TOKEN) \
          -v $(System.DefaultWorkingDirectory):/usr/src \
          sonarsource/sonar-scanner-cli:latest \
          -Dsonar.projectKey=$(SONARQUBE_PROJECT_KEY) \
          -Dsonar.projectName="$(SONARQUBE_PROJECT_NAME)" \
          -Dsonar.sources=backend-a,backend-b \
          -Dsonar.qualitygate.wait=true
      displayName: "Run SonarQube Analysis (Docker Scanner)"
      env:
        SONARQUBE_TOKEN: $(SONARQUBE_TOKEN)

    - script: |
        wget https://github.com/jeremylong/DependencyCheck/releases/download/v9.0.9/dependency-check-9.0.9-release.zip
        unzip dependency-check-9.0.9-release.zip
        ./dependency-check/bin/dependency-check.sh \
          --scan ./backend-a/package.json \
          --scan ./backend-b/package.json \
          --format HTML \
          --format JSON \
          --out $(Build.ArtifactStagingDirectory)/dependency-check \
          --failOnCVSS 9 \
          --suppression ./dependency-check-suppressions.xml || true
      displayName: "OWASP Dependency Check - Scan Dependencies"
      continueOnError: false

    - script: |
        if [ -f "$(Build.ArtifactStagingDirectory)/dependency-check/dependency-check-report.json" ]; then
          CRITICAL_COUNT=$(cat $(Build.ArtifactStagingDirectory)/dependency-check/dependency-check-report.json | grep -o '"severity":"CRITICAL"' | wc -l)
          echo "Critical vulnerabilities found: $CRITICAL_COUNT"
          if [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "##vso[task.logissue type=error]CRITICAL vulnerabilities found in dependencies!"
            exit 1
          fi
        fi
      displayName: "Fail Build if Critical Vulnerabilities Found"

    - task: PublishBuildArtifacts@1
      condition: always()
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/dependency-check'
        ArtifactName: 'dependency-check-reports'
      displayName: "Publish OWASP Dependency Check Reports"

    - task: AzureCLI@2
      displayName: "Azure Login ACR"
      inputs:
        azureSubscription: $(AZURE_SERVICE_CONNECTION)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          az acr login --name $(ACR_NAME)

    - script: |
        docker build -t backend-a-local ./backend-a
        docker build -t backend-b-local ./backend-b
      displayName: "Build Docker Images"

    - script: |
        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
          | sh -s -- -b /usr/local/bin
      displayName: "Install Trivy"

    - script: |
        trivy image --severity CRITICAL --exit-code 1 backend-a-local
        trivy image --severity CRITICAL --exit-code 1 backend-b-local
      displayName: "Fail Build if Critical CVEs Found"

    - script: |
        docker tag backend-a-local $(ACR_LOGIN_SERVER)/backend-a-moath:latest
        docker tag backend-b-local $(ACR_LOGIN_SERVER)/backend-b-moath:latest
        docker push $(ACR_LOGIN_SERVER)/backend-a-moath:latest
        docker push $(ACR_LOGIN_SERVER)/backend-b-moath:latest
      displayName: "Push Images to ACR"

# =========================================================
# COMMON INGRESS INSTALL FUNCTION
# =========================================================

# =========================================================
# DEV
# =========================================================
- stage: Dev
  dependsOn: Build
  jobs:
  - deployment: DeployDev
    environment: dev
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            displayName: "Deploy DEV"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |

                az aks get-credentials -g rg-moath-dev -n aks-moath-dev --overwrite-existing

                curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

                kubectl create ns ingress-nginx --dry-run=client -o yaml | kubectl apply -f -

                helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                helm repo update

                helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                  --namespace ingress-nginx

                kubectl wait --namespace ingress-nginx \
                  --for=condition=ready pod \
                  --selector=app.kubernetes.io/component=controller \
                  --timeout=300s

                kubectl apply -f k8s/namespaces/dev.yaml

                kubectl create secret generic postgres-secret-moath \
                  --from-literal=POSTGRES_PASSWORD=$(DB_PASSWORD_DEV) \
                  -n moath-webapp-dev --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -k k8s/overlays/dev

                # ========================================
                # Install Prometheus & Grafana
                # ========================================
                kubectl create ns monitoring --dry-run=client -o yaml | kubectl apply -f -

                # Ensure NSG rules allow HTTP/HTTPS traffic (idempotent)
                az network nsg rule create \
                  --resource-group MC_rg-moath-dev_aks-moath-dev_westus2 \
                  --nsg-name aks-agentpool-72219259-nsg \
                  --name Allow-HTTP-Inbound \
                  --priority 1000 \
                  --source-address-prefixes '*' \
                  --destination-port-ranges 80 \
                  --access Allow \
                  --protocol Tcp \
                  --direction Inbound 2>/dev/null || echo "NSG rule already exists"

                az network nsg rule create \
                  --resource-group MC_rg-moath-dev_aks-moath-dev_westus2 \
                  --nsg-name aks-agentpool-72219259-nsg \
                  --name Allow-HTTPS-Inbound \
                  --priority 1001 \
                  --source-address-prefixes '*' \
                  --destination-port-ranges 443 \
                  --access Allow \
                  --protocol Tcp \
                  --direction Inbound 2>/dev/null || echo "NSG rule already exists"

                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                helm repo add grafana https://grafana.github.io/helm-charts
                helm repo update

                helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
                  --namespace monitoring \
                  --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
                  --set grafana.adminPassword=admin123 \
                  --set grafana.service.type=LoadBalancer \
                  --set grafana.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-internal"=false

                # Deploy ServiceMonitors for backend pods
                kubectl apply -f k8s/monitoring/servicemonitor.yaml -n moath-webapp-dev || true

                # Deploy Grafana dashboards
                kubectl apply -f k8s/monitoring/grafana-dashboard.yaml || true

                # Fix Grafana LoadBalancer service configuration
                kubectl annotate service prometheus-grafana -n monitoring service.beta.kubernetes.io/azure-load-balancer-internal=false --overwrite || true
                kubectl annotate service prometheus-grafana -n monitoring service.beta.kubernetes.io/azure-allowed-ip-ranges="" --overwrite || true

                # ========================================
                # Install Loki
                # ========================================
                helm upgrade --install loki grafana/loki-stack \
                  --namespace monitoring \
                  --set grafana.enabled=false \
                  --set prometheus.enabled=false \
                  --set loki.persistence.enabled=true \
                  --set loki.persistence.size=10Gi

                # ========================================
                # Install ArgoCD
                # ========================================
                kubectl create ns argocd --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

                kubectl wait --namespace argocd \
                  --for=condition=ready pod \
                  --selector=app.kubernetes.io/name=argocd-server \
                  --timeout=300s

                kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

                # Deploy ArgoCD Applications for GitOps
                kubectl apply -f k8s/argocd/application-dev.yaml
                kubectl apply -f k8s/argocd/application-qa.yaml
                kubectl apply -f k8s/argocd/application-prod.yaml

                echo "Waiting for Ingress IP..."
                kubectl get ingress -n moath-webapp-dev

                INGRESS_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                GRAFANA_IP=$(kubectl get service prometheus-grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                ARGOCD_IP=$(kubectl get service argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

                echo "=========================================="
                echo "DEV Ingress URL: http://$INGRESS_IP/api/a"
                echo "DEV Ingress URL: http://$INGRESS_IP/api/b"
                echo "=========================================="
                echo "Grafana URL: http://$GRAFANA_IP"
                echo "Grafana Login: admin / admin123"
                echo "=========================================="
                echo "ArgoCD URL: https://$ARGOCD_IP"
                echo "ArgoCD Login: admin / $ARGOCD_PASSWORD"
                echo "=========================================="

# =========================================================
# QA
# =========================================================
- stage: QA
  dependsOn: Dev
  jobs:
  - deployment: DeployQA
    environment: qa
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            displayName: "Deploy QA"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |

                az aks get-credentials -g rg-moath-qa -n aks-moath-qa --overwrite-existing

                curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

                kubectl create ns ingress-nginx --dry-run=client -o yaml | kubectl apply -f -

                helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                helm repo update

                helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                  --namespace ingress-nginx

                kubectl wait --namespace ingress-nginx \
                  --for=condition=ready pod \
                  --selector=app.kubernetes.io/component=controller \
                  --timeout=300s

                kubectl apply -f k8s/namespaces/qa.yaml

                kubectl create secret generic postgres-secret-moath \
                  --from-literal=POSTGRES_PASSWORD=$(DB_PASSWORD_QA) \
                  -n moath-webapp-qa --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -k k8s/overlays/qa

                # ========================================
                # Install Prometheus & Grafana
                # ========================================
                kubectl create ns monitoring --dry-run=client -o yaml | kubectl apply -f -

                # Ensure NSG rules allow HTTP/HTTPS traffic (idempotent)
                az network nsg rule create \
                  --resource-group MC_rg-moath-qa_aks-moath-qa_westus2 \
                  --nsg-name aks-agentpool-25353439-nsg \
                  --name Allow-HTTP-Inbound \
                  --priority 1000 \
                  --source-address-prefixes '*' \
                  --destination-port-ranges 80 \
                  --access Allow \
                  --protocol Tcp \
                  --direction Inbound 2>/dev/null || echo "NSG rule already exists"

                az network nsg rule create \
                  --resource-group MC_rg-moath-qa_aks-moath-qa_westus2 \
                  --nsg-name aks-agentpool-25353439-nsg \
                  --name Allow-HTTPS-Inbound \
                  --priority 1001 \
                  --source-address-prefixes '*' \
                  --destination-port-ranges 443 \
                  --access Allow \
                  --protocol Tcp \
                  --direction Inbound 2>/dev/null || echo "NSG rule already exists"

                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                helm repo add grafana https://grafana.github.io/helm-charts
                helm repo update

                helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
                  --namespace monitoring \
                  --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
                  --set grafana.adminPassword=admin123 \
                  --set grafana.service.type=LoadBalancer \
                  --set grafana.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-internal"=false

                # Deploy ServiceMonitors for backend pods
                kubectl apply -f k8s/monitoring/servicemonitor.yaml -n moath-webapp-qa || true

                # Deploy Grafana dashboards
                kubectl apply -f k8s/monitoring/grafana-dashboard.yaml || true

                # Fix Grafana LoadBalancer service configuration
                kubectl annotate service prometheus-grafana -n monitoring service.beta.kubernetes.io/azure-load-balancer-internal=false --overwrite || true
                kubectl annotate service prometheus-grafana -n monitoring service.beta.kubernetes.io/azure-allowed-ip-ranges="" --overwrite || true

                # ========================================
                # Install Loki
                # ========================================
                helm upgrade --install loki grafana/loki-stack \
                  --namespace monitoring \
                  --set grafana.enabled=false \
                  --set prometheus.enabled=false \
                  --set loki.persistence.enabled=true \
                  --set loki.persistence.size=10Gi

                # ========================================
                # Install ArgoCD
                # ========================================
                kubectl create ns argocd --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

                kubectl wait --namespace argocd \
                  --for=condition=ready pod \
                  --selector=app.kubernetes.io/name=argocd-server \
                  --timeout=300s

                kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

                # Deploy ArgoCD Applications for GitOps
                kubectl apply -f k8s/argocd/application-dev.yaml
                kubectl apply -f k8s/argocd/application-qa.yaml
                kubectl apply -f k8s/argocd/application-prod.yaml

                echo "Waiting for Ingress IP..."
                kubectl get ingress -n moath-webapp-qa

                INGRESS_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                GRAFANA_IP=$(kubectl get service prometheus-grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                ARGOCD_IP=$(kubectl get service argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

                echo "=========================================="
                echo "QA Ingress URL: http://$INGRESS_IP/api/a"
                echo "QA Ingress URL: http://$INGRESS_IP/api/b"
                echo "=========================================="
                echo "Grafana URL: http://$GRAFANA_IP"
                echo "Grafana Login: admin / admin123"
                echo "=========================================="
                echo "ArgoCD URL: https://$ARGOCD_IP"
                echo "ArgoCD Login: admin / $ARGOCD_PASSWORD"
                echo "=========================================="

# =========================================================
# PROD
# =========================================================
- stage: Prod
  dependsOn: QA
  jobs:
  - deployment: DeployProd
    environment: prod
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - task: AzureCLI@2
            displayName: "Deploy PROD"
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |

                az aks get-credentials -g rg-moath-prod -n aks-moath-prod --overwrite-existing

                curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

                kubectl create ns ingress-nginx --dry-run=client -o yaml | kubectl apply -f -

                helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                helm repo update

                helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                  --namespace ingress-nginx

                kubectl wait --namespace ingress-nginx \
                  --for=condition=ready pod \
                  --selector=app.kubernetes.io/component=controller \
                  --timeout=300s

                kubectl apply -f k8s/namespaces/prod.yaml

                kubectl create secret generic postgres-secret-moath \
                  --from-literal=POSTGRES_PASSWORD=$(DB_PASSWORD_PROD) \
                  -n moath-webapp-prod --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -k k8s/overlays/prod

                # ========================================
                # Install Prometheus & Grafana
                # ========================================
                kubectl create ns monitoring --dry-run=client -o yaml | kubectl apply -f -

                # Ensure NSG rules allow HTTP/HTTPS traffic (idempotent)
                az network nsg rule create \
                  --resource-group MC_rg-moath-prod_aks-moath-prod_westus2 \
                  --nsg-name aks-agentpool-40887715-nsg \
                  --name Allow-HTTP-Inbound \
                  --priority 1000 \
                  --source-address-prefixes '*' \
                  --destination-port-ranges 80 \
                  --access Allow \
                  --protocol Tcp \
                  --direction Inbound 2>/dev/null || echo "NSG rule already exists"

                az network nsg rule create \
                  --resource-group MC_rg-moath-prod_aks-moath-prod_westus2 \
                  --nsg-name aks-agentpool-72219259-nsg \
                  --name Allow-HTTPS-Inbound \
                  --priority 1001 \
                  --source-address-prefixes '*' \
                  --destination-port-ranges 443 \
                  --access Allow \
                  --protocol Tcp \
                  --direction Inbound 2>/dev/null || echo "NSG rule already exists"

                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                helm repo add grafana https://grafana.github.io/helm-charts
                helm repo update

                helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
                  --namespace monitoring \
                  --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
                  --set grafana.adminPassword=admin123 \
                  --set grafana.service.type=LoadBalancer \
                  --set grafana.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-internal"=false

                # Deploy ServiceMonitors for backend pods
                kubectl apply -f k8s/monitoring/servicemonitor.yaml -n moath-webapp-prod || true

                # Deploy Grafana dashboards
                kubectl apply -f k8s/monitoring/grafana-dashboard.yaml || true

                # Fix Grafana LoadBalancer service configuration
                kubectl annotate service prometheus-grafana -n monitoring service.beta.kubernetes.io/azure-load-balancer-internal=false --overwrite || true
                kubectl annotate service prometheus-grafana -n monitoring service.beta.kubernetes.io/azure-allowed-ip-ranges="" --overwrite || true

                # ========================================
                # Install Loki
                # ========================================
                helm upgrade --install loki grafana/loki-stack \
                  --namespace monitoring \
                  --set grafana.enabled=false \
                  --set prometheus.enabled=false \
                  --set loki.persistence.enabled=true \
                  --set loki.persistence.size=10Gi

                # ========================================
                # Install ArgoCD
                # ========================================
                kubectl create ns argocd --dry-run=client -o yaml | kubectl apply -f -

                kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

                kubectl wait --namespace argocd \
                  --for=condition=ready pod \
                  --selector=app.kubernetes.io/name=argocd-server \
                  --timeout=300s

                kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

                # Deploy ArgoCD Applications for GitOps
                kubectl apply -f k8s/argocd/application-dev.yaml
                kubectl apply -f k8s/argocd/application-qa.yaml
                kubectl apply -f k8s/argocd/application-prod.yaml

                echo "Waiting for Ingress IP..."
                kubectl get ingress -n moath-webapp-prod

                INGRESS_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                GRAFANA_IP=$(kubectl get service prometheus-grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                ARGOCD_IP=$(kubectl get service argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)

                echo "=========================================="
                echo "PROD Ingress URL: http://$INGRESS_IP/api/a"
                echo "PROD Ingress URL: http://$INGRESS_IP/api/b"
                echo "=========================================="
                echo "Grafana URL: http://$GRAFANA_IP"
                echo "Grafana Login: admin / admin123"
                echo "=========================================="
                echo "ArgoCD URL: https://$ARGOCD_IP"
                echo "ArgoCD Login: admin / $ARGOCD_PASSWORD"
                echo "=========================================="
